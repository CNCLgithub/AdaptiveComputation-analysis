---
title: "Exp 2"
output:
  pdf_document: default
  html_document:
    df_print: paged
header-includes:
 \usepackage{booktabs}
 \usepackage{longtable}
 \usepackage{array}
 \usepackage{multirow}
 \usepackage{wrapfig}
 \usepackage{float}
 \floatplacement{figure}{H}
---

# Setup

```{r , include=FALSE}
knitr::opts_chunk$set(fig.pos = 'H', 
                      echo=TRUE, warning=FALSE, message=FALSE)

library(tidyverse)
library(ggplot2)
library(readr)
library(boot)

th <- theme_classic()
theme_set(th)
```

load data (subject, exp, scenes)


## Model and Design data

> TODO: look at mode of predicted assignment

Loading non-subject data 

```{r echo=FALSE, results='hide'}

# scene, frame
probe_timings <- read_csv("../data/exp2/exp2_probe_map_random.csv") %>%
  filter(scene <= 40) %>%
  group_by(scene, frame) %>%
  summarise() %>%
  ungroup() %>%
  mutate(probe = frame) %>%
  group_by(scene) %>%
  mutate(epoch = dense_rank(frame)) %>%
  ungroup()

# TODO rename - Mario 11/03/2022
# contains tracker id for each probe - not using eccentricity data
# # scene, frame, tracker, eccentricity...
probe_tracker_data <- read_csv("../data/exp2/exp2_probe_map_random_eccentricity.csv") %>%
  filter(scene <= 40) %>%
  select(scene, frame, tracker)

# accuracy per tracker
# scene, tracker, acc, chain
model_perf <- read_csv("../data/exp2/exp2_probes_target_designation_perf.csv") %>%
group_by(scene, tracker) %>%
  summarise(across(td_acc, list(mu = mean, sd = sd)))

# cycles per frame
# scene, frame, tracker, cycles, chain
model_att <- read_csv("../data/exp2/exp2_probes_target_designation_att.csv")

# distance to nearest distractor
# (not possible to extract directly from model predictions)
dnd_predictions <- read_csv("../data/exp2/exp2_probes_dnd.csv") %>%
  select(scene, frame, d_ic) %>%
  rename(dist_to_nd = d_ic)

```

```{r results='hide'}

model_smoothing = 8.0
# add smoothing
inf_data <- model_att %>%
  group_by(chain, scene, tracker) %>%
   # add smoothing
  nest_by() %>%
  mutate(att_xy = list(with(data,
                          ksmooth(frame, importance, kernel = "normal",
                                  bandwidth = model_smoothing)))) %>%
  mutate(importance_smoothed = list(att_xy$y)) %>%
  unnest(cols = c(data, importance_smoothed)) %>%
  dplyr::select(-c(att_xy)) %>%
  ungroup()
  
# sum up the total amount of attention
# and computed weighted tracker centroids
# tau = 17.5
centroids <- inf_data %>%
  group_by(scene, chain, frame) %>%
  summarise(total_cycles = sum(cycles),
            weighted_x = sum(pred_x * importance_smoothed),
            weighted_y = sum(pred_y * importance_smoothed),
            geo_x = mean(pred_x),
            geo_y = mean(pred_y)) %>%
  ungroup()

# add distance to weighted and unweighted tracker means
inf_data <- inf_data %>%
  left_join(centroids, by = c("scene", "chain", "frame")) %>%
  mutate(a3_centroid = sqrt((weighted_x - pred_x)^2 + (weighted_y - pred_y)^2),
         geo_centroid = sqrt((geo_x - pred_x)^2 + (geo_y - pred_y)^2),
         dist_to_center = sqrt(pred_x^2 + pred_y^2),
         # con_centroid = sqrt((con_x - pred_x)^2 + (con_y - pred_y)^2)
         ) %>%
  group_by(scene, frame, tracker) %>%
  summarise(across(-chain, list(mu = mean, sd = sd))) %>%
  ungroup()

# merge all covariates
exp_data <- probe_tracker_data %>%
  left_join(inf_data, by = c("scene", "frame", "tracker")) %>%
  left_join(dnd_predictions, by = c("scene", "frame"))
```

## Subject Data

screen bad subjects


```{r echo=TRUE, results='hide'}
subject_data <- read_csv("../data/exp2/parsed_trials_exp2_random_probes.csv") %>%
  select(-c(WID)) %>%
  replace_na(list(response_frame = Inf))

hit_window = 48 # subjects hit if response 1.5s after probe onset
probe_space = 60 # 2.5 seconds between probes
with_probes <- subject_data %>%
  nest_by(ID) %>%
  mutate(full = list(right_join(data, probe_timings, by = "scene"))) %>%
  select(-data) %>%
  unnest(cols = full) %>%
  mutate(delta_t = response_frame - frame,
         hit = between(delta_t, 0, hit_window),
         fp = between(delta_t, hit_window+1, probe_space)) %>%
  ungroup()
```




```{r}
hr_by_subj_scene <- with_probes %>%
  group_by(ID, scene, probe) %>%
  summarise(hit = any(hit)) %>%
  group_by(ID, scene) %>%
  summarise(hr = mean(hit))

fp_by_subj_scene <- with_probes %>%
  group_by(ID, scene, response_frame) %>%
  summarise(fp = any(fp)) %>%
  group_by(ID, scene) %>%
  summarise(fpr = mean(fp))

probe_by_subj <- hr_by_subj_scene %>%
  left_join(fp_by_subj_scene) %>%
  group_by(ID) %>%
  summarise(hr = mean(hr),
            fp = mean(fpr))

td_by_subj_tracker <- subject_data %>%
  pivot_longer(cols = starts_with("td"), 
               names_to = "tracker", 
               values_to = "td") %>%
  separate(tracker, c("NA", "tracker")) %>%
  mutate(tracker = as.numeric(tracker)) %>%
  group_by(ID, scene, tracker) %>%
  summarise(td = first(td)) 

td_by_subj_scene <- td_by_subj_tracker %>%
  group_by(ID, scene) %>%
  summarise(td = mean(td))

td_by_subj <- td_by_subj_tracker %>%
  group_by(ID) %>%
  summarise(td_acc_mu = mean(td),
            n = n(),
            td_acc_se = sd(td) / sqrt(n)) 

perf_thresh = 2.5
subject_performance <- td_by_subj %>%
  left_join(probe_by_subj) %>%
  mutate(passed = (td_acc_mu - 0.5) > perf_thresh*td_acc_se & (hr - fp > 0.05),
         high_perf = hr - fp > 0.4)

good_subjects_data <- subject_performance %>%
  filter(passed) %>%
  select(ID) %>%
  left_join(with_probes, by = "ID") %>%
  left_join(hr_by_subj_scene) %>%
  left_join(td_by_subj_scene, by = c("ID", "scene")) %>%
  ungroup() 
# %>%
# filter(td == 1)

n_passed = sum(subject_performance$passed)

```

# Analysis



## Causal effects

First collect all data points (no averaging across scene)

The the average treatment effect, ATE, is indentified over attention on probe detection
regardless of target designation accuracy.

The condititional average treatement effect, CATE, is the ATE conditioned on
correct (4/4) target designation.


```{r}
hr_by_probe <- good_subjects_data %>%
  # sorting out probed tracker
  pivot_longer(cols = starts_with("probe_"), 
               names_to = "probed_tracker_epoch",
               values_to = "tracker") %>%
  separate(probed_tracker_epoch, c(NA, NA, "probed_tracker_epoch")) %>%
  mutate(probed_tracker_epoch = as.numeric(probed_tracker_epoch)) %>%
  group_by(ID, scene, probe, epoch, probed_tracker_epoch, tracker) %>%
  filter(probed_tracker_epoch == epoch, hit | fp) %>%
  ungroup() %>%
  group_by(scene, epoch, probe, tracker) %>%
  summarise(hr = sum(hit) / n_passed,
            td = mean(td),
            rt = mean(delta_t),
            n = n()) %>%
  ungroup() %>%
  rename(frame = probe) 

ate_by_probe <- exp_data %>%
  left_join(hr_by_probe, by = c("scene", "frame", "tracker")) %>%
  mutate(hr = ifelse(is.na(hr), 0, hr)) %>%
  group_by(scene) %>%
  mutate(a3_centroid_rank = rank(a3_centroid_mu),
         hr.rank = rank(hr)) %>%
  ungroup()

```



## Sanity checks for scene level variation

```{r}

ate_by_probe %>%
  ggplot(aes(hr, fill = factor(scene))) +
  geom_histogram() +
  guides(color = FALSE)

ate_by_probe %>%
  summarise(acc = mean(td))
model_perf %>%
  ungroup() %>%
  summarise(a.cc = mean(td_acc_mu))
```


Focusing on specific scene

```{r}
spec_scene = c(24, 40)


timing_data <- good_subjects_data %>%
  ungroup() %>%
  filter(scene %in% spec_scene) %>%
  nest_by(ID) %>%
  mutate(idata = list(filter(inf_data, scene %in% spec_scene)),
         full = list(left_join(idata, data, by = c("scene", "frame")))) %>%
  select(-c(data, idata)) %>%
  unnest(cols = full) %>%
  select(scene, frame, tracker, a3_centroid_mu, a3_centroid_sd, probe, ID, response_frame) %>%
  ungroup()

timing_data %>%
  ggplot(aes(x = frame)) +
  geom_line(aes(y = a3_centroid_mu, color = factor(tracker))) +
  geom_ribbon(aes(ymin = a3_centroid_mu-a3_centroid_sd, 
                  ymax=a3_centroid_mu+a3_centroid_sd, 
                  color = factor(tracker)),
              alpha = 0.2) +
  geom_vline(aes(xintercept = probe, color = "probe_onset"), linetype = "dashed") + 
  geom_histogram(aes(x =  response_frame), binwidth = 6) +
  facet_grid(rows = vars(scene))

ate_by_probe %>% filter(scene == 40) %>% select(scene, frame, tracker, hr, a3_centroid_mu, geo_centroid_mu)
```


```{r}
ate_by_probe %>%
  group_by(epoch) %>%
  summarise(hr = mean(hr)) %>%
  ggplot(aes(x = epoch, y = hr)) +
  geom_col()

subject_performance %>%
  filter(passed) %>%
  ggplot(aes(x = factor(ID), y = hr - fp)) +
  geom_col()
```


## Predicting probe hit rate with univariate models


Here, we evaluate the ability of each model (adaptive computation as well as several heuristics models)
to predict probe hit rate. 

In general this is accomplished by computing a "center of attention" and using... TODO
```{r Covariates on hit rate}

ate_by_probe %>%
  ggplot(aes(x = a3_centroid_mu, y = hr)) +
  geom_point(color = "#5aa67b", size = 3.1) + 
  geom_smooth(method = "lm", color = "black") +
  theme_classic() +
  ggtitle("HR ~ Attention Centroid")

ate_by_probe %>%
  ggplot(aes(x = geo_centroid_mu, y = hr)) +
  geom_point() + 
  ggtitle("HR ~ Target Center")

ate_by_probe %>%
  ggplot(aes(x = dist_to_nd, y = hr)) +
  geom_point() + 
  ggtitle("HR ~ Nearest Distractor")

ate_by_probe %>%
  ggplot(aes(x = dist_to_center_mu, y = hr)) +
  geom_point() + 
  ggtitle("HR ~ Origin")
```

Linear model fitting and bootstrap analysis 


```{r Univariate linear fits}

print("Adaptive computation centroid")
ate_by_probe %>%
  with(lm(hr ~ a3_centroid_mu,)) %>%
  summary()

print("Target center")
ate_by_probe %>%
  with(lm(hr ~ geo_centroid_mu,)) %>%
  summary()


print("Distance to nearest distractor")
ate_by_probe %>%
  with(lm(hr ~ dist_to_nd,)) %>%
  summary()

print("Distance to origin")
ate_by_probe %>%
  with(lm(hr ~ dist_to_center_mu,)) %>%
  summary()
```
```{r Fig 2C}
ate_by_probe %>%
  ggplot(aes(x = a3_centroid_mu, y = hr)) +
  geom_point(color = "#5aa67b", size = 3.1) + 
  geom_smooth(method = "lm", color = "black") +
  theme_classic() 
```


```{r Univariate boot strap test}
set.seed(0) # TODO: Should we set this seed?

# subj_data_nested <- good_subjects_data %>%
#   ungroup() %>%
#   # sorting out probed tracker
#   pivot_longer(cols = starts_with("probe_"), 
#                names_to = "probed_tracker_epoch",
#                values_to = "tracker") %>%
#   separate(probed_tracker_epoch, c(NA, NA, "probed_tracker_epoch")) %>%
#   mutate(probed_tracker_epoch = as.numeric(probed_tracker_epoch)) %>%
#   group_by(ID, scene, probe, epoch, probed_tracker_epoch, tracker) %>%
#   filter(probed_tracker_epoch == epoch, hit | fp) %>%
#   ungroup() %>%
#   select(ID, scene, epoch, probe, tracker, probed_tracker_epoch, hit) %>%
#   nest_by(ID)

# univariate_test <- function(predictor, data, indices) {
#   d = data[indices,] #allows boot to select sample of subjects
#   k = length(indices)
#   # average over subject points
#   full_d <- d %>% 
#     unnest(cols = c(ID, data)) %>%
#     group_by(scene, epoch, probe, tracker) %>%
#     summarise(hr = sum(hit) / k,
#               .groups = "keep",) %>%
#     ungroup %>%
#     mutate(frame = probe) %>%
#     left_join(exp_data, by = c("scene", "frame", "tracker"))
#   fit = full_d %>% with(lm(as.formula(paste("hr ~", predictor)))) %>% summary
#   return(fit$r.squared) #return explained variance
#   # fit = cor.test(as.formula(paste("~ hr +", predictor)), data = full_d)
#   # return (fit$estimate)
# }

univariate_test <- function(data, indices) {
  d = data[indices,] # sample trials with replacement 
  k = length(indices)
  ac = d %>% with(lm(hr ~ a3_centroid_mu)) %>% summary
  tc = d %>% with(lm(hr ~ geo_centroid_mu)) %>% summary
  nd = d %>% with(lm(hr ~ dist_to_nd)) %>% summary
  or = d %>% with(lm(hr ~ dist_to_center_mu)) %>% summary
  result <- c(ac$r.squared,
              tc$r.squared, 
              nd$r.squared,
              or$r.squared)
  return(result) #return explained variance
}

univ_boostrap_steps = 10000
```


```{r univariate bootstraps}
reps <- boot(data=ate_by_probe, 
             statistic=univariate_test,
             R=univ_boostrap_steps, 
             ncpus = 2,
             parallel = "multicore")
#view results of boostrapping
reps
plot(reps,1)
plot(reps,2)
plot(reps,3)
plot(reps,4)
#calculate adjusted bootstrap percentile (BCa) interval

univ_cis_hr_ac <- boot.ci(reps, type="bca", index=1) # ac
univ_cis_hr_tc <- boot.ci(reps, type="bca", index=2) # tc
univ_cis_hr_nd <- boot.ci(reps, type="bca", index=3) # nd
univ_cis_hr_or <- boot.ci(reps, type="bca", index=4) # or
```


## Comparing models


### Direct bootstrapped hypothesis testing

The test uses a random sample of subjects (with replacement) to measure the
frequency of the attention centroid producing a higher absolute correlation
to a given heuristic model.

```{r}
# dbht_function <- function(data, heuristic, indices) {
#   d <- data[indices,] #allows boot to select sample of subjects
#   k <- length(indices)
#   # average over subject points
#   full_d <- d %>% 
#     unnest(cols = c(ID, data)) %>%
#     group_by(scene, epoch, probe, tracker) %>%
#     summarise(hr = sum(hit) / k,
#               .groups = "keep",) %>%
#     ungroup %>%
#     mutate(frame = probe) %>%
#     left_join(exp_data, by = c("scene", "frame", "tracker"))
#   ac_r = cor.test(~ hr + a3_centroid_mu, data = full_d)
#   hu_r = cor.test(as.formula(paste("~ hr +", heuristic)), data = full_d)
#   return(abs(ac_r$estimate) > abs(hu_r$estimate)) 
# }

dbht_function <- function(data, indices) {
  d = data[indices,] # sample trials with replacement 
  k = length(indices)
  ac_r <- cor.test(~ hr + a3_centroid_mu, data = d)
  tc_r <- cor.test(~ hr + geo_centroid_mu, data = d)
  nd_r <- cor.test(~ hr + dist_to_nd, data = d)
  or_r <- cor.test(~ hr + dist_to_center_mu, data = d)
  result <- c(abs(ac_r$estimate) > abs(tc_r$estimate),
              abs(ac_r$estimate) > abs(nd_r$estimate),
              abs(ac_r$estimate) > abs(or_r$estimate))
  return(result)
}


dbht_steps = 5000
```


```{r Attention centroid vs heuristics}
reps <- boot(data=ate_by_probe, 
             statistic=dbht_function,
             R=dbht_steps, 
             ncpus = 2, 
             parallel = "multicore")

#calculate pval
dbht_tc_p_val = 1.0 - (sum(reps$t[, 1]) / reps$R)
dbht_tc_p_val
dbht_nd_p_val = 1.0 - (sum(reps$t[, 2]) / reps$R)
dbht_nd_p_val
dbht_or_p_val = 1.0 - (sum(reps$t[, 3]) / reps$R)
dbht_or_p_val
```


Across all comparisons, the attention centroid forms a stronger correlation
to probe hit rate (p < .001).


```{r Fig 2D-i}
univ_fig <- function() {
  data.frame(model = c("ac", "tc", "nd", "or"),
             conf.low = c(univ_cis_hr_ac$bca[4], 
                          univ_cis_hr_tc$bca[4],
                          univ_cis_hr_nd$bca[4],
                          univ_cis_hr_or$bca[4]),
             conf.high= c(univ_cis_hr_ac$bca[5], 
                          univ_cis_hr_tc$bca[5],
                          univ_cis_hr_nd$bca[5],
                          univ_cis_hr_or$bca[5]),
             heuristic = factor(c(0, 1, 1, 1))) %>%
  mutate(r = 0.5 * (conf.low + conf.high)) %>%
  ggplot(aes(x = reorder(model, -conf.high), y = r, fill = heuristic)) + 
  geom_col(width = 0.5) +
geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.075, size = 0.7) + 
theme(legend.position = "none",
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        # axis.text = element_blank(),
        aspect.ratio = 1
        )
}
withr::with_options(
  list(ggplot2.discrete.fill = c("#5aa67b", "#6d9eeb")),
  print(univ_fig())
)

```

### Residual bootstrapped comparisons

```{r}
set.seed(0) # TODO: Should we set this seed?

residual_test <- function(predictor, covariate, data, indices) {
  d <- data[indices,] #allows boot to select sample of subjects
  # average over subject points
  full_d <- d %>% 
    unnest(cols = c(ID, data)) %>%
    group_by(scene, epoch, probe, tracker) %>%
    summarise(hr = sum(hit) / n_passed,
              .groups = "keep",) %>%
    ungroup %>%
    mutate(frame = probe) 
  
  full_d <- exp_data %>%
    left_join(full_d, by = c("scene", "frame", "tracker")) %>%
    mutate(hr = ifelse(is.na(hr), 0, hr))
  # partial regressions
  res_pred <- lm(as.formula(paste(predictor, " ~ ", covariate)),
                  data = full_d)
  res_hr <- lm(as.formula(paste("hr ~ ", covariate)),
                  data = full_d)
  res_data <- data.frame(pred = res_pred$residuals,
                         hr = res_hr$residuals)
  fit <- cor.test(as.formula("~ hr + pred"),
                  data = res_data)
  return(fit$estimate) #return R2 of model
}

res_bootstrap_steps = 1000
```

```{r Covariate - Attention Centroid}
reps <- boot(data=subj_data_nested, 
             statistic=residual_test, 
             R=res_bootstrap_steps, 
             predictor = "geo_centroid_mu",
             covariate = "a3_centroid_mu",
             ncpus = 2,  parallel = "multicore")
reps
plot(reps)
res_ac_tc <- boot.ci(reps, type="bca")
res_ac_tc

reps <- boot(data=subj_data_nested, 
             statistic=residual_test, 
             R=res_bootstrap_steps, 
             predictor = "dist_to_nd",
             covariate = "a3_centroid_mu",
             ncpus = 2,  parallel = "multicore")
reps
plot(reps)
res_ac_nd <- boot.ci(reps, type="bca")
res_ac_nd

reps <- boot(data=subj_data_nested, 
             statistic=residual_test, 
             R=res_bootstrap_steps, 
             predictor = "dist_to_center_mu",
             covariate = "a3_centroid_mu",
             ncpus = 2,  parallel = "multicore")
reps
plot(reps)
res_ac_or <- boot.ci(reps, type="bca")
res_ac_or
```

```{r Covariate - Target Center}
reps <- boot(data=subj_data_nested, 
             statistic=residual_test, 
             R=res_bootstrap_steps, 
             predictor = "a3_centroid_mu",
             covariate = "geo_centroid_mu",
             ncpus = 2,  parallel = "multicore")
reps
plot(reps)
res_tc_ac <- boot.ci(reps, type="bca")
res_tc_ac

reps <- boot(data=subj_data_nested, 
             statistic=residual_test, 
             R=res_bootstrap_steps, 
             predictor = "dist_to_nd",
             covariate = "geo_centroid_mu",
             ncpus = 2,  parallel = "multicore")
reps
plot(reps)
res_tc_nd <- boot.ci(reps, type="bca")
res_tc_nd

reps <- boot(data=subj_data_nested, 
             statistic=residual_test, 
             R=res_bootstrap_steps, 
             predictor = "dist_to_center_mu",
             covariate = "geo_centroid_mu",
             ncpus = 2,  parallel = "multicore")
reps
plot(reps)
res_tc_or <- boot.ci(reps, type="bca")
res_tc_or
```
```{r Covariate - Nearest Distractor}
reps <- boot(data=subj_data_nested, 
             statistic=residual_test, 
             R=res_bootstrap_steps, 
             predictor = "a3_centroid_mu",
             covariate = "dist_to_nd",
             ncpus = 2,  parallel = "multicore")
reps
plot(reps)
res_nd_ac <- boot.ci(reps, type="bca")
res_nd_ac

reps <- boot(data=subj_data_nested, 
             statistic=residual_test, 
             R=res_bootstrap_steps, 
             predictor = "geo_centroid_mu",
             covariate = "dist_to_nd",
             ncpus = 2,  parallel = "multicore")
reps
plot(reps)
res_nd_tc <- boot.ci(reps, type="bca")
res_nd_tc

reps <- boot(data=subj_data_nested, 
             statistic=residual_test, 
             R=res_bootstrap_steps, 
             predictor = "dist_to_center_mu",
             covariate = "dist_to_nd",
             ncpus = 2,  parallel = "multicore")
reps
plot(reps)
res_nd_or <- boot.ci(reps, type="bca")
res_nd_or
```

```{r Covariate - Origin}
reps <- boot(data=subj_data_nested, 
             statistic=residual_test, 
             R=res_bootstrap_steps, 
             predictor = "a3_centroid_mu",
             covariate = "dist_to_center_mu",
             ncpus = 2,  parallel = "multicore")
reps
plot(reps)
res_or_ac <- boot.ci(reps, type="bca")
res_or_ac

reps <- boot(data=subj_data_nested, 
             statistic=residual_test, 
             R=res_bootstrap_steps, 
             predictor = "geo_centroid_mu",
             covariate = "dist_to_center_mu",
             ncpus = 2,  parallel = "multicore")
reps
plot(reps)
res_or_tc <- boot.ci(reps, type="bca")
res_or_tc

reps <- boot(data=subj_data_nested, 
             statistic=residual_test, 
             R=res_bootstrap_steps, 
             predictor = "dist_to_nd",
             covariate = "dist_to_center_mu",
             ncpus = 2,  parallel = "multicore")
reps
plot(reps)
res_or_nd <- boot.ci(reps, type="bca")
res_or_nd
```



## SI


### Accuracy

```{r}

td_by_scene <- td_by_subj_scene %>%
  group_by(scene) %>%
  summarise(td_human = mean(td),
            td_human_sd = sd(td))

td_by_scene <- model_perf %>%
  group_by(scene) %>%
  summarise(td_model = mean(td_acc_mu),
          td_model_sd = sd(td_acc_mu)) %>%
  left_join(td_by_scene, by = "scene")

td_lr <- td_by_scene %>%
  with(lm(td_human ~ td_model))

td_by_scene$td_human_res = td_lr$residuals
td_by_scene <- td_by_scene %>%
  mutate(abs_res = abs(td_human_res))

td_lr %>% summary()

td_by_scene %>%
  ggplot(aes(x = td_model, y = td_human)) +
  geom_point() + 
  geom_smooth(method = "lm")
```

```{r}
subj_data_nested <- good_subjects_data %>%
  ungroup() %>%
  select(ID,scene, td) %>%
  nest_by(ID)

avg_group <- function(group) {
  means <- group %>%
    unnest(cols = c(ID, data)) %>%
    group_by(scene) %>%
    summarise(td = mean(td),
              .groups = "keep",) %>%
    ungroup
  return(means$td)
}

split_half_cor <- function(data, indices) {
  d <- data.frame(data)
  nr = length(indices)
  groups <- split(indices, 
                  cut(seq_along(indices), 2, labels = FALSE))
  gai = groups[[1]]
  gbi = groups[[2]]
  group_a <- avg_group(d[gai,])
  group_b <- avg_group(d[gbi,])
  df = data.frame(x = group_a,
                  y = group_b)
  fit <- df %>% with(lm(y ~ x))
  return (summary(fit)$r.square)
}
reps <- boot(data = subj_data_nested, 
             statistic=split_half_cor,
             sim = "permutation",
             R=1000)
plot(reps)
#calculate adjusted bootstrap percentile (BCa) interval
cis_hr_ac_res <- boot.ci(reps, type="bca")
cis_hr_ac_res
```


# Scratch 


### high att trials

```{r}

high_att <- ate_by_probe %>%
  filter(high_att)

ate_by_probe %>%
  ggplot(aes(x = ttwm, y = hr)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  facet_wrap(vars(high_att))



tttm_ttwm <- high_att %>%
  with(lm(ttwm ~ tttm))
tttm_ttwm %>%
  summary()


high_att$pred_ttwm <- tttm_ttwm %>%
  predict(high_att)

tttm_hr <- high_att %>%
  with(lm(hr ~ tttm))

tttm_hr %>%
  summary()


high_att$pred_hr <- tttm_hr %>%
  predict(high_att)

high_att <- high_att %>%
  mutate(res_ttwm = ttwm - pred_ttwm,
         res_hr = hr - pred_hr)


res_res_fit <- high_att %>%
  with(lm(res_hr ~ res_ttwm))
res_res_fit %>% 
  summary()

high_att$pred_res_hr <- res_res_fit %>%
  predict(high_att)
high_att <- high_att %>%
  mutate(res_res_hr = res_hr - pred_res_hr)

high_att %>%
  ggplot(aes(x = res_ttwm, y = res_hr)) +
  geom_point() + 
  geom_smooth(method = "lm")

ttwm_tttm <- high_att %>%
  with(lm_robust(tttm ~ ttwm,
                 # fixed_effects = ~ scene
                 ))
ttwm_tttm %>%
  summary()


high_att$pred_tttm <- ttwm_tttm %>%
  predict(high_att)

ttwm_hr <- high_att %>%
  with(lm_robust(hr ~ ttwm))

ttwm_hr %>%
  summary()


high_att$pred_hr <- ttwm_hr %>%
  predict(high_att)

high_att <- high_att %>%
  mutate(res_tttm = tttm - pred_tttm,
         res_hr = hr - pred_hr)


res_res_fit <- high_att %>%
  with(lm_robust(res_hr ~ res_tttm))
res_res_fit %>% 
  summary()

```

### Looking at subject bimodality

```{r}

split_hr_by_probe <- good_subjects_data %>%
  # sorting out probed tracker
  pivot_longer(cols = starts_with("probe_"), 
               names_to = "probed_tracker_epoch",
               values_to = "tracker") %>%
  separate(probed_tracker_epoch, c(NA, NA, "probed_tracker_epoch")) %>%
  mutate(probed_tracker_epoch = as.numeric(probed_tracker_epoch)) %>%
  group_by(ID, scene, probe, epoch, probed_tracker_epoch, tracker) %>%
  filter(probed_tracker_epoch == epoch) %>%
  summarise(hit = any(hit),
            td = mean(td),
            n = n()) %>%
  ungroup() %>%
  left_join(subject_performance, by = c("ID")) %>%
  group_by(scene, epoch, probe, tracker, high_perf) %>%
  summarise(hr = mean(hit),
            td = mean(td),
            n = n()) %>%
  ungroup()

split_ate_by_probe <- split_hr_by_probe %>%
  mutate(frame = probe) %>%
  left_join(exp_data, by = c("scene", "epoch", "frame", "tracker")) %>%
  ungroup() %>%
filter(high_perf)

split_ate_by_probe %>%
  ggplot(aes(x = ttwm, y = hr)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  facet_wrap(vars(high_perf))



tttm_ttwm <- split_ate_by_probe %>%
  with(lm(ttwm ~ tttm))
tttm_ttwm %>%
  summary()


split_ate_by_probe$pred_ttwm <- tttm_ttwm %>%
  predict(split_ate_by_probe)

tttm_hr <- split_ate_by_probe %>%
  with(lm(hr ~ tttm))

tttm_hr %>%
  summary()


split_ate_by_probe$pred_hr <- tttm_hr %>%
  predict(split_ate_by_probe)

split_ate_by_probe <- split_ate_by_probe %>%
  mutate(res_ttwm = ttwm - pred_ttwm,
         res_hr = hr - pred_hr)


res_res_fit <- split_ate_by_probe %>%
  with(lm(res_hr ~ res_ttwm))
res_res_fit %>% 
  summary()

split_ate_by_probe$pred_res_hr <- res_res_fit %>%
  predict(split_ate_by_probe)
split_ate_by_probe <- split_ate_by_probe %>%
  mutate(res_res_hr = res_hr - pred_res_hr)

split_ate_by_probe %>%
  ggplot(aes(x = res_ttwm, y = res_hr)) +
  geom_point() + 
  geom_smooth(method = "lm")

ttwm_tttm <- split_ate_by_probe %>%
  with(lm_robust(tttm ~ ttwm,
                 # fixed_effects = ~ scene
                 ))
ttwm_tttm %>%
  summary()


split_ate_by_probe$pred_tttm <- ttwm_tttm %>%
  predict(split_ate_by_probe)

ttwm_hr <- split_ate_by_probe %>%
  with(lm_robust(hr ~ ttwm))

ttwm_hr %>%
  summary()


split_ate_by_probe$pred_hr <- ttwm_hr %>%
  predict(split_ate_by_probe)

split_ate_by_probe <- split_ate_by_probe %>%
  mutate(res_tttm = tttm - pred_tttm,
         res_hr = hr - pred_hr)


res_res_fit <- split_ate_by_probe %>%
  with(lm_robust(res_hr ~ res_tttm))
res_res_fit %>% 
  summary()
```


```{r}

# for effect size + conf interval
ate_by_probe %>%
  with(lm_robust(hr ~ zttwm + tracker_to_dot_mean )) %>%
  summary()

# for variance explained

tttm_ttwm <- ate_by_probe %>%
  with(lm_robust(zttwm ~ tracker_to_dot_mean,
                 # fixed_effects = ~ scene
                 ))
tttm_ttwm %>%
  summary()


ate_by_probe$pred_ttwm <- tttm_ttwm %>%
  predict(ate_by_probe)

tttm_hr <- ate_by_probe %>%
  with(lm_robust(hr ~ tracker_to_dot_mean))

tttm_hr %>%
  summary()


ate_by_probe$pred_hr <- tttm_hr %>%
  predict(ate_by_probe)

ate_by_probe <- ate_by_probe %>%
  mutate(res_ttwm = zttwm - pred_ttwm,
         res_hr = hr - pred_hr)


res_res_fit <- ate_by_probe %>%
  with(lm_robust(res_hr ~ res_ttwm))
res_res_fit %>% 
  summary()

ate_by_probe %>%
  ggplot(aes(x = res_ttwm, y = res_hr)) +
  geom_point(aes(color = tracker_to_dot_mean)) + 
  geom_smooth(method = "lm")


```
with fixed effects 

```{r}

# for effect size + conf interval
ate_by_probe %>%
  with(lm_robust(hr ~ zttwm + ztttm, fixed_effects =  ~ scene)) %>%
  summary()

# for variance explained

tttm_ttwm <- ate_by_probe %>%
  with(lm_robust(zttwm ~ ztttm, fixed_effects =  ~ scene))
tttm_ttwm %>%
  summary()


ate_by_probe$pred_ttwm <- tttm_ttwm %>%
  predict(ate_by_probe)

tttm_hr <- ate_by_probe %>%
  with(lm_robust(hr ~ ztttm, fixed_effects =  ~ scene))

tttm_hr %>%
  summary()


ate_by_probe$pred_hr <- tttm_hr %>%
  predict(ate_by_probe)

ate_by_probe <- ate_by_probe %>%
  mutate(res_ttwm = zttwm - pred_ttwm,
         res_hr = hr - pred_hr)


res_res_fit <- ate_by_probe %>%
  with(lm_robust(res_hr ~ res_ttwm))
res_res_fit %>% 
  summary()

ate_by_probe$pred_res_hr <- res_res_fit %>%
  predict(ate_by_probe)
ate_by_probe <- ate_by_probe %>%
  mutate(res_res_hr = res_hr - pred_res_hr)

ate_by_probe %>%
  top_n(5, abs(res_res_hr))
ate_by_probe %>%
  top_n(-5, abs(res_res_hr))

ate_by_probe %>%
  ggplot(aes(x = res_ttwm, y = res_hr)) +
  geom_point(aes(color = log_att_lead)) + 
  geom_smooth(method = "lm")

```
